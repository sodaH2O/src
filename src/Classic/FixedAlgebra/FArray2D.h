#ifndef CLASSIC_FArray2D_HH
#define CLASSIC_FArray2D_HH

// ------------------------------------------------------------------------
// $RCSfile: FArray2D.h,v $
// ------------------------------------------------------------------------
// $Revision: 1.1.1.1.2.3 $
// ------------------------------------------------------------------------
// Copyright: see Copyright.readme
// ------------------------------------------------------------------------
//
// Template class: FArray2D<T,N>
//
// ------------------------------------------------------------------------
// Class category: FixedAlgebra
// ------------------------------------------------------------------------
//
// $Date: 2004/11/18 22:18:06 $
// $Author: jsberg $
//
// ------------------------------------------------------------------------

#include "FixedAlgebra/FArray1D.h"
#include "FixedAlgebra/FSlice.h"
#include "Utilities/CLRangeError.h"
#include <algorithm>
#include <iosfwd>
#include <iomanip>


// Template class FArray2D<T,M,N>
// ------------------------------------------------------------------------
/// A templated representation for 2-dimensional arrays.
//  This version has fixed dimensions.  It implements storage management
//  and access, but contains no arithmetic operations.
//  The destructor generated by the compiler performs the correct operation.
//  For speed reasons it is not implemented.

template<class T, int M, int N>
class FArray2D {

public:

    /// The value type of the array.
    typedef T value_type;

    /// Iterator for the array.
    typedef T *iterator;

    /// Iterator for constant array.
    typedef const T *const_iterator;

    /// Iterator for access by rows.
    typedef T *row_iterator;

    /// Iterator for access by rows.
    typedef const T *const_row_iterator;

    /// Iterator for access by columns.
    typedef FSlice<T, N> col_iterator;

    /// Iterator for access by columns.
    typedef FConstSlice<T, N> const_col_iterator;

    /// Default constructor.
    //  Constructs zero array.
    FArray2D();

    /// Constructor.
    //  Set all array elements to [b]t[/b].
    explicit FArray2D(const T &t);

    /// Copy constructor.
    FArray2D(const FArray2D &);

    /// Assignment.
    const FArray2D<T, M, N> &operator=(const FArray2D<T, M, N> &);

    /// Get element.
    //  Return a reference to the element in row [b]r[/b] and column [b]c[/b].
    T &operator()(int r, int c);

    /// Get element.
    //  Return a constant reference to the element in row [b]r[/b] and
    //  column [b]c[/b].
    const T &operator()(int r, int c) const;

    /// Get number of rows.
    int nrows() const;

    /// Get number of columns.
    int ncols() const;

    /// Get total size.
    int size() const;

    /// Get beginning of data.
    //  The array is interpreted as a one-dimensional array.
    //  Version for non-constant array.
    iterator begin();

    /// Get pointer past end of data.
    //  The array is interpreted as a one-dimensional array.
    //  Version for non-constant array.
    iterator end();

    /// Get beginning of data.
    //  The array is interpreted as a one-dimensional array.
    //  Version for constant array.
    const_iterator begin() const;

    /// Get pointer past end of data.
    //  The array is interpreted as a one-dimensional array.
    //  Version for constant array.
    const_iterator end() const;

    /// Get row iterator.
    //  Return pointer to beginning of row [b]r[/b].
    //  Throw RangeError, if [b]r[/b] is out of range.
    row_iterator row_begin(int r);

    /// Get row iterator.
    //  Return pointer past end of row [b]r[/b].
    //  Throw RangeError, if [b]r[/b] is out of range.
    row_iterator row_end(int r);

    /// Get row iterator.
    //  Return pointer to beginning of constant row [b]r[/b].
    //  Throw RangeError, if [b]r[/b] is out of range.
    const_row_iterator row_begin(int r) const;

    /// Get row iterator.
    //  Return pointer past end of constant row [b]r[/b].
    //  Throw RangeError, if [b]r[/b] is out of range.
    const_row_iterator row_end(int r) const;

    /// Get row iterator.
    //  Return pointer to beginning of row [b]r[/b].
    //  Result is undefined, if [b]r[/b] is out of range.
    row_iterator operator[](int r);

    /// Get row iterator.
    //  Return pointer to beginning of row [b]r[/b].
    //  Result is undefined, if [b]r[/b] is out of range.
    const_row_iterator operator[](int r) const;

    /// Get column iterator.
    //  Return pointer to beginning of column [b]c[/b].
    //  Throw RangeError if [b]c[/b] is out of range.
    col_iterator col_begin(int c);

    /// Get column iterator.
    //  Return pointer past end of column [b]c[/b].
    //  Throw RangeError if [b]c[/b] is out of range.
    col_iterator col_end(int c);

    /// Get column iterator.
    //  Return pointer to beginning of column [b]c[/b].
    //  Throw RangeError if [b]c[/b] is out of range.
    const_col_iterator col_begin(int c) const;

    /// Get column iterator.
    //  Return pointer past end of column [b]c[/b].
    //  Throw RangeError if [b]c[/b] is out of range.
    const_col_iterator col_end(int c) const;

    /// Fetch column.
    //  Copy column [b]c[/b] into [b]toArray[/b].
    //  Throw RangeError if [b]c[/b] is out of range.
    void getColumn(FArray1D<T, M> &toArray, int c) const;

    /// Fetch row.
    //  Copy row [b]r[/b] into [b]toArray[/b].
    void getRow(FArray1D<T, N> &toArray, int r) const;

    /// Store column.
    //  Copy [b]fromArray[/b] to column [b]c[/b].
    //  Throw RangeError if [b]c[/b] is out of range.
    void putColumn(const FArray1D<T, M> &fromArray, int c);

    /// Store row.
    //  Copy [b]fromArray[/b] to row [b]r[/b].
    //  Throw RangeError if [b]r[/b] is out of range.
    void putRow(const FArray1D<T, N> &fromArray, int r);

    /// Exchange columns.
    //  Exchange columns [b]c1[/b] and [b]c2[/b].
    //  Throw RangeError, if either index is out of range.
    void swapColumns(int c1, int c2);

    /// Exchange rows.
    //  Exchange rows [b]r1[/b] and [b]r2[/b].
    //  Throw RangeError, if either index is out of range.
    void swapRows(int r1, int r2);

protected:

    // Array data.
    T data[M*N];

    // Array size.
    static const int SIZE = M *N;
};


// Template implementation.
// ------------------------------------------------------------------------

template <class T, int M, int N>
inline FArray2D<T, M, N>::FArray2D() {
    std::fill(begin(), end(), T(0));
}


template <class T, int M, int N>
inline FArray2D<T, M, N>::FArray2D(const T &val) {
    std::fill(begin(), end(), val);
}


template<class T, int M, int N>
FArray2D<T, M, N>::FArray2D(const FArray2D &rhs) {
    std::copy(rhs.begin(), rhs.end(), begin());
}


template<class T, int M, int N>
const FArray2D<T, M, N> &FArray2D<T, M, N>::operator=(const FArray2D &rhs) {
    std::copy(rhs.begin(), rhs.end(), begin());
    return *this;
}


template <class T, int M, int N>
inline T &FArray2D<T, M, N>::operator()(int r, int c) {
    if(r >= M  ||  c >= N) {
        throw CLRangeError("FArray2D::operator()", "Index out of range.");
    }
    return data[N*r+c];
}


template <class T, int M, int N>
inline const T &FArray2D<T, M, N>::operator()(int r, int c) const {
    if(r >= M  ||  c >= N) {
        throw CLRangeError("FArray2D::operator()", "Index out of range.");
    }
    return data[N*r+c];
}


template <class T, int M, int N>
inline int FArray2D<T, M, N>::nrows() const {
    return M;
}


template <class T, int M, int N>
inline int FArray2D<T, M, N>::ncols() const {
    return N;
}


template <class T, int M, int N>
inline int FArray2D<T, M, N>::size() const {
    return SIZE;
}


template <class T, int M, int N>
inline typename FArray2D<T, M, N>::iterator FArray2D<T, M, N>::begin() {
    return data;
}


template <class T, int M, int N>
inline typename FArray2D<T, M, N>::iterator FArray2D<T, M, N>::end() {
    return data + SIZE;
}


template <class T, int M, int N>
inline typename FArray2D<T, M, N>::const_iterator FArray2D<T, M, N>::begin() const {
    return data;
}


template <class T, int M, int N>
inline typename FArray2D<T, M, N>::const_iterator FArray2D<T, M, N>::end() const {
    return data + SIZE;
}


template <class T, int M, int N>
typename FArray2D<T, M, N>::row_iterator FArray2D<T, M, N>::row_begin(int r) {
    if(r >= M) {
        throw CLRangeError("FArray2D::row_begin()", "Row index out of range.");
    }
    return data + N * r;
}


template <class T, int M, int N>
typename FArray2D<T, M, N>::row_iterator FArray2D<T, M, N>::row_end(int r) {
    if(r >= M) {
        throw CLRangeError("FArray2D::row_end()", "Row index out of range.");
    }
    return data + N * (r + 1);
}


template <class T, int M, int N>
typename FArray2D<T, M, N>::const_row_iterator FArray2D<T, M, N>::row_begin(int r) const {
    if(r >= M) {
        throw CLRangeError("FArray2D::row_begin()", "Row index out of range.");
    }
    return data + N * r;
}


template <class T, int M, int N>
typename FArray2D<T, M, N>::const_row_iterator FArray2D<T, M, N>::row_end(int r) const {
    if(r >= M) {
        throw CLRangeError("FArray2D::row_end()", "Row index out of range.");
    }
    return data + N * (r + 1);
}


template <class T, int M, int N>
typename FArray2D<T, M, N>::row_iterator FArray2D<T, M, N>::operator[](int r) {
    return data + N * r;
}


template <class T, int M, int N>
typename FArray2D<T, M, N>::const_row_iterator FArray2D<T, M, N>::operator[](int r) const {
    return data + N * r;
}


template <class T, int M, int N>
typename FArray2D<T, M, N>::col_iterator FArray2D<T, M, N>::col_begin(int c) {
    if(c >= N) {
        throw CLRangeError("FArray2D::col_begin()", "Column index out of range.");
    }
    return col_iterator(begin() + c);
}


template <class T, int M, int N>
typename FArray2D<T, M, N>::col_iterator FArray2D<T, M, N>::col_end(int c) {
    if(c >= N) {
        throw CLRangeError("FArray2D::col_end()", "Column index out of range.");
    }
    return col_iterator(end() + c);
}


template <class T, int M, int N>
typename FArray2D<T, M, N>::const_col_iterator FArray2D<T, M, N>::col_begin(int c) const {
    if(c >= N) {
        throw CLRangeError("FArray2D::col_begin()", "Column index out of range.");
    }
    return const_col_iterator(begin() + c);
}


template <class T, int M, int N>
typename FArray2D<T, M, N>::const_col_iterator FArray2D<T, M, N>::col_end(int c) const {
    if(c >= N) {
        throw CLRangeError("FArray2D::col_end()", "Column index out of range.");
    }
    return const_col_iterator(end() + c);
}


template <class T, int M, int N>
void FArray2D<T, M, N>::getColumn(FArray1D<T, M> &toArray, int c) const {
    std::copy(col_begin(c), col_end(c), toArray.begin());
}


template <class T, int M, int N>
void FArray2D<T, M, N>::getRow(FArray1D<T, N> &toArray, int r) const {
    std::copy(row_begin(r), row_end(r), toArray.begin());
}


template <class T, int M, int N>
void FArray2D<T, M, N>::putColumn(const FArray1D<T, M> &fromArray, int c) {
    std::copy(fromArray.begin(), fromArray.end(), col_begin(c));
}


template <class T, int M, int N>
void FArray2D<T, M, N>::putRow(const FArray1D<T, N> &fromArray, int r) {
    std::copy(fromArray.begin(), fromArray.end(), row_begin(r));
}


template <class T, int M, int N>
void FArray2D<T, M, N>::swapColumns(int col1, int col2) {
    std::swap_ranges(col_begin(col1), col_end(col1), col_begin(col2));
}


template <class T, int M, int N>
void FArray2D<T, M, N>::swapRows(int row1, int row2) {
    std::swap_ranges(row_begin(row1), row_end(row1), row_begin(row2));
}


template <class T, int M, int N>
std::ostream &operator<<(std::ostream &os, const FArray2D<T, M, N> &v) {
    // next two lines require changes when g++ library becomes standard.
    std::streamsize old_prec = os.precision(12);
    os.setf(std::ios::scientific, std::ios::floatfield);

    for(int i = 0; i < M; ++i) {
        for(int j = 0; j < N; ++j) {
            os << std::setw(20) << v[i][j] << " ";
        }
        os << std::endl;
    }

    // next two lines require changes when g++ library becomes standard.
    os.setf(std::ios::fixed, std::ios::floatfield);
    os.precision(old_prec);
    return os;
}


#endif // CLASSIC_FArray2D_HH
